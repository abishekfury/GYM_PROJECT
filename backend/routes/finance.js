const express = require('express');
const router = express.Router();
const { Income, Expense } = require('../models/Finance');
const rateLimit = require('express-rate-limit');

// Rate limiting for financial operations
const financeLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 50, // Limit each IP to 50 requests per windowMs
    message: {
        error: 'Too many financial requests. Please try again later.'
    }
});

router.use(financeLimiter);

// ==============
// INCOME ROUTES
// ==============

// Get all income records
router.get('/income', async (req, res) => {
    try {
        const { startDate, endDate, category, isAutoGenerated } = req.query;
        let query = {};
        
        // Date range filter
        if (startDate || endDate) {
            query.date = {};
            if (startDate) query.date.$gte = new Date(startDate);
            if (endDate) query.date.$lte = new Date(endDate);
        }
        
        // Category filter
        if (category) query.category = category;
        
        // Auto-generated filter
        if (isAutoGenerated !== undefined) {
            query.isAutoGenerated = isAutoGenerated === 'true';
        }
        
        const income = await Income.find(query)
            .populate('memberId', 'name memberCode')
            .sort({ date: -1, createdAt: -1 });
            
        res.json(income);
    } catch (error) {
        console.error('Error fetching income:', error);
        res.status(500).json({ error: 'Failed to fetch income records' });
    }
});

// Get income by ID
router.get('/income/:id', async (req, res) => {
    try {
        const income = await Income.findById(req.params.id)
            .populate('memberId', 'name memberCode');
        
        if (!income) {
            return res.status(404).json({ error: 'Income record not found' });
        }
        
        res.json(income);
    } catch (error) {
        console.error('Error fetching income by ID:', error);
        res.status(500).json({ error: 'Failed to fetch income record' });
    }
});

// Create new income record
router.post('/income', async (req, res) => {
    try {
        const {
            title,
            amount,
            category,
            description,
            paymentMethod,
            date,
            isAutoGenerated,
            memberId,
            memberCode
        } = req.body;
        
        const income = new Income({
            title,
            amount,
            category,
            description,
            paymentMethod,
            date: date ? new Date(date) : new Date(),
            isAutoGenerated: isAutoGenerated || false,
            memberId,
            memberCode
        });
        
        const savedIncome = await income.save();
        const populatedIncome = await Income.findById(savedIncome._id)
            .populate('memberId', 'name memberCode');
            
        res.status(201).json(populatedIncome);
    } catch (error) {
        console.error('Error creating income:', error);
        if (error.name === 'ValidationError') {
            res.status(400).json({ error: error.message });
        } else {
            res.status(500).json({ error: 'Failed to create income record' });
        }
    }
});

// Update income record
router.put('/income/:id', async (req, res) => {
    try {
        const {
            title,
            amount,
            category,
            description,
            paymentMethod,
            date
        } = req.body;
        
        const income = await Income.findById(req.params.id);
        
        if (!income) {
            return res.status(404).json({ error: 'Income record not found' });
        }
        
        // Prevent editing auto-generated income records
        if (income.isAutoGenerated) {
            return res.status(400).json({ 
                error: 'Auto-generated income records cannot be edited' 
            });
        }
        
        const updatedIncome = await Income.findByIdAndUpdate(
            req.params.id,
            {
                title,
                amount,
                category,
                description,
                paymentMethod,
                date: date ? new Date(date) : income.date
            },
            { new: true, runValidators: true }
        ).populate('memberId', 'name memberCode');
        
        res.json(updatedIncome);
    } catch (error) {
        console.error('Error updating income:', error);
        if (error.name === 'ValidationError') {
            res.status(400).json({ error: error.message });
        } else {
            res.status(500).json({ error: 'Failed to update income record' });
        }
    }
});

// Delete income record
router.delete('/income/:id', async (req, res) => {
    try {
        const income = await Income.findById(req.params.id);
        
        if (!income) {
            return res.status(404).json({ error: 'Income record not found' });
        }
        
        // Prevent deleting auto-generated income records
        if (income.isAutoGenerated) {
            return res.status(400).json({ 
                error: 'Auto-generated income records cannot be deleted' 
            });
        }
        
        await Income.findByIdAndDelete(req.params.id);
        res.json({ message: 'Income record deleted successfully' });
    } catch (error) {
        console.error('Error deleting income:', error);
        res.status(500).json({ error: 'Failed to delete income record' });
    }
});

// ==============
// EXPENSE ROUTES
// ==============

// Get all expense records
router.get('/expenses', async (req, res) => {
    try {
        const { startDate, endDate, category } = req.query;
        let query = {};
        
        // Date range filter
        if (startDate || endDate) {
            query.date = {};
            if (startDate) query.date.$gte = new Date(startDate);
            if (endDate) query.date.$lte = new Date(endDate);
        }
        
        // Category filter
        if (category) query.category = category;
        
        const expenses = await Expense.find(query).sort({ date: -1, createdAt: -1 });
        res.json(expenses);
    } catch (error) {
        console.error('Error fetching expenses:', error);
        res.status(500).json({ error: 'Failed to fetch expense records' });
    }
});

// Get expense by ID
router.get('/expenses/:id', async (req, res) => {
    try {
        const expense = await Expense.findById(req.params.id);
        
        if (!expense) {
            return res.status(404).json({ error: 'Expense record not found' });
        }
        
        res.json(expense);
    } catch (error) {
        console.error('Error fetching expense by ID:', error);
        res.status(500).json({ error: 'Failed to fetch expense record' });
    }
});

// Create new expense record
router.post('/expenses', async (req, res) => {
    try {
        const {
            title,
            amount,
            category,
            description,
            paymentMethod,
            date
        } = req.body;
        
        const expense = new Expense({
            title,
            amount,
            category,
            description,
            paymentMethod,
            date: date ? new Date(date) : new Date()
        });
        
        const savedExpense = await expense.save();
        res.status(201).json(savedExpense);
    } catch (error) {
        console.error('Error creating expense:', error);
        if (error.name === 'ValidationError') {
            res.status(400).json({ error: error.message });
        } else {
            res.status(500).json({ error: 'Failed to create expense record' });
        }
    }
});

// Update expense record
router.put('/expenses/:id', async (req, res) => {
    try {
        const {
            title,
            amount,
            category,
            description,
            paymentMethod,
            date
        } = req.body;
        
        const updatedExpense = await Expense.findByIdAndUpdate(
            req.params.id,
            {
                title,
                amount,
                category,
                description,
                paymentMethod,
                date: date ? new Date(date) : undefined
            },
            { new: true, runValidators: true }
        );
        
        if (!updatedExpense) {
            return res.status(404).json({ error: 'Expense record not found' });
        }
        
        res.json(updatedExpense);
    } catch (error) {
        console.error('Error updating expense:', error);
        if (error.name === 'ValidationError') {
            res.status(400).json({ error: error.message });
        } else {
            res.status(500).json({ error: 'Failed to update expense record' });
        }
    }
});

// Delete expense record
router.delete('/expenses/:id', async (req, res) => {
    try {
        const deletedExpense = await Expense.findByIdAndDelete(req.params.id);
        
        if (!deletedExpense) {
            return res.status(404).json({ error: 'Expense record not found' });
        }
        
        res.json({ message: 'Expense record deleted successfully' });
    } catch (error) {
        console.error('Error deleting expense:', error);
        res.status(500).json({ error: 'Failed to delete expense record' });
    }
});

// ====================
// FINANCIAL ANALYTICS
// ====================

// Get financial summary
router.get('/summary', async (req, res) => {
    try {
        const { startDate, endDate } = req.query;
        let dateQuery = {};
        
        if (startDate || endDate) {
            dateQuery = {};
            if (startDate) dateQuery.$gte = new Date(startDate);
            if (endDate) dateQuery.$lte = new Date(endDate);
        }
        
        const matchStage = dateQuery.constructor === Object && Object.keys(dateQuery).length > 0 
            ? { date: dateQuery }
            : {};

        // Calculate income summary
        const incomeAggregation = await Income.aggregate([
            { $match: matchStage },
            {
                $group: {
                    _id: null,
                    totalIncome: { $sum: '$amount' },
                    autoGeneratedIncome: {
                        $sum: { $cond: [{ $eq: ['$isAutoGenerated', true] }, '$amount', 0] }
                    },
                    manualIncome: {
                        $sum: { $cond: [{ $eq: ['$isAutoGenerated', false] }, '$amount', 0] }
                    },
                    count: { $sum: 1 }
                }
            }
        ]);

        // Calculate expense summary
        const expenseAggregation = await Expense.aggregate([
            { $match: matchStage },
            {
                $group: {
                    _id: null,
                    totalExpenses: { $sum: '$amount' },
                    count: { $sum: 1 }
                }
            }
        ]);

        // Income by category
        const incomeByCategory = await Income.aggregate([
            { $match: matchStage },
            {
                $group: {
                    _id: '$category',
                    amount: { $sum: '$amount' },
                    count: { $sum: 1 }
                }
            },
            { $sort: { amount: -1 } }
        ]);

        // Expenses by category
        const expensesByCategory = await Expense.aggregate([
            { $match: matchStage },
            {
                $group: {
                    _id: '$category',
                    amount: { $sum: '$amount' },
                    count: { $sum: 1 }
                }
            },
            { $sort: { amount: -1 } }
        ]);

        const incomeData = incomeAggregation[0] || { totalIncome: 0, autoGeneratedIncome: 0, manualIncome: 0, count: 0 };
        const expenseData = expenseAggregation[0] || { totalExpenses: 0, count: 0 };

        const summary = {
            totalIncome: incomeData.totalIncome,
            autoGeneratedIncome: incomeData.autoGeneratedIncome,
            manualIncome: incomeData.manualIncome,
            totalExpenses: expenseData.totalExpenses,
            netProfit: incomeData.totalIncome - expenseData.totalExpenses,
            incomeCount: incomeData.count,
            expenseCount: expenseData.count,
            incomeByCategory: incomeByCategory.map(item => ({
                category: item._id,
                amount: item.amount,
                count: item.count
            })),
            expensesByCategory: expensesByCategory.map(item => ({
                category: item._id,
                amount: item.amount,
                count: item.count
            }))
        };

        res.json(summary);
    } catch (error) {
        console.error('Error generating financial summary:', error);
        res.status(500).json({ error: 'Failed to generate financial summary' });
    }
});

module.exports = router;